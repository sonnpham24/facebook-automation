require('dotenv').config();
const express = require('express');
const axios = require('axios');
const path = require('path');
const multer = require('multer');
const fs = require('fs');
const FormData = require('form-data');
const { scheduleJob, scheduledJobs, cancelJob } = require('node-schedule');
const { Sequelize } = require('sequelize');

const sequelize = new Sequelize(
  process.env.DB_NAME,
  process.env.DB_USER,
  process.env.DB_PASSWORD,
  {
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    dialect: 'postgres',
    logging: false, // T·∫Øt log query trong console
    pool: {
      max: 5,
      min: 0,
      acquire: 30000,
      idle: 10000
    }
  }
);

// Ki·ªÉm tra k·∫øt n·ªëi database
(async () => {
  try {
    await sequelize.authenticate();
    console.log('‚úÖ K·∫øt n·ªëi database th√†nh c√¥ng');
  } catch (error) {
    console.error('‚ùå L·ªói k·∫øt n·ªëi database:', error);
    process.exit(1); // Tho√°t n·∫øu kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c
  }
})();

// Kh·ªüi t·∫°o model
const CommentTemplate = require('./models/CommentTemplate')(sequelize, Sequelize.DataTypes);
const UserAccount = require('./models/UserAccount')(sequelize, Sequelize.DataTypes);

const app = express();
const PORT = process.env.PORT || 3000;
const fileFilter = (req, file, cb) => {
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'video/mp4', 'video/quicktime'];
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Ch·ªâ h·ªó tr·ª£ file ·∫£nh (JPEG, PNG, GIF) v√† video (MP4, MOV)'), false);
  }
};
const upload = multer({
  dest: 'uploads/',
  limits: { fileSize: 100 * 1024 * 1024 }, // 100MB
  fileFilter
});
const scheduledPosts = {};

// ƒê·ªìng b·ªô database
(async () => {
  try {
    await sequelize.sync({ alter: true }); // Th√™m alter: true ƒë·ªÉ t·ª± ƒë·ªông c·∫≠p nh·∫≠t schema
    console.log('ƒê·ªìng b·ªô model th√†nh c√¥ng');
  } catch (error) {
    console.error('L·ªói ƒë·ªìng b·ªô model:', error);
  }
})();

// C·∫•u h√¨nh middleware
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// Bi·∫øn to√†n c·ª•c l∆∞u tr·ªØ t·∫°m token
let pageAccessToken = null;

// Bi·∫øn to√†n c·ª•c b·∫≠t/t·∫Øt AI chatbot
let aiReplyEnabled = true; // M·∫∑c ƒë·ªãnh b·∫≠t

// Trang ch·ªß v·ªõi form ƒëƒÉng b√†i
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'index.html'));
});

// ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn Facebook ƒë·ªÉ x√°c th·ª±c
app.get('/auth/facebook', (req, res) => {
    const authUrl = `https://www.facebook.com/v19.0/dialog/oauth?client_id=${process.env.APP_ID}&redirect_uri=${process.env.REDIRECT_URI}&scope=pages_manage_posts,pages_read_engagement,pages_show_list,pages_manage_metadata,pages_manage_engagement`;
    res.redirect(authUrl);
});

// Callback x·ª≠ l√Ω token
app.get('/auth/facebook/callback', async (req, res) => {
    try {
      const { code } = req.query;
      
      if (!code) {
        throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c code t·ª´ Facebook');
      }
  
      // 1. L·∫•y user access token
      const tokenResponse = await axios.get(
        `https://graph.facebook.com/v19.0/oauth/access_token?client_id=${process.env.APP_ID}&client_secret=${process.env.APP_SECRET}&code=${code}&redirect_uri=${process.env.REDIRECT_URI}`
      );
  
      const userAccessToken = tokenResponse.data.access_token;
      console.log('User Access Token:', userAccessToken); // Debug
  
      // 2. L·∫•y danh s√°ch trang qu·∫£n l√Ω
      const pagesResponse = await axios.get(
        `https://graph.facebook.com/v19.0/me/accounts?access_token=${userAccessToken}`
      );
      
      const pages = pagesResponse.data.data;
      console.log('Danh s√°ch trang:', pages); // Debug
  
      if (!pages || pages.length === 0) {
        throw new Error('T√†i kho·∫£n kh√¥ng qu·∫£n l√Ω trang n√†o');
      }
  
      // 3. T√¨m trang theo PAGE_ID
      const targetPage = pages.find(page => page.id === process.env.PAGE_ID);
      if (!targetPage) {
        throw new Error(`Kh√¥ng t√¨m th·∫•y trang v·ªõi ID ${process.env.PAGE_ID} ho·∫∑c kh√¥ng c√≥ quy·ªÅn`);
      }
  
      pageAccessToken = targetPage.access_token;
      console.log('Page Access Token:', pageAccessToken); // Debug

      // ƒêƒÉng k√Ω webhook cho Page
      try {
        await axios.post(
          `https://graph.facebook.com/v19.0/${process.env.PAGE_ID}/subscribed_apps`,
          {
            subscribed_fields: ['feed']
          },
          {
            params: {
              access_token: pageAccessToken
            }
          }
        );
        console.log('‚úÖ ƒê√£ ƒëƒÉng k√Ω webhook cho Page th√†nh c√¥ng!');
      } catch (err) {
        console.error('‚ùå L·ªói khi ƒëƒÉng k√Ω webhook cho Page:', err.response?.data || err.message);
      }
      try {
        await axios.delete(
          `https://graph.facebook.com/v19.0/${process.env.PAGE_ID}/subscribed_apps`,
          {
            params: {
              access_token: pageAccessToken
            }
          }
        );
        console.log('üßπ ƒê√£ g·ª° ƒëƒÉng k√Ω webhook c≈© (reset)');
      } catch (err) {
        console.error('‚ùå L·ªói khi g·ª° ƒëƒÉng k√Ω c≈©:', err.response?.data || err.message);
      }
      try {
        await axios.post(
          `https://graph.facebook.com/v19.0/${process.env.PAGE_ID}/subscribed_apps`,
          {
            subscribed_fields: ['feed', 'conversations']
          },
          {
            params: {
              access_token: pageAccessToken
            }
          }
        );
        console.log('‚úÖ ƒê√£ ƒëƒÉng k√Ω webhook cho Page th√†nh c√¥ng (l·∫°i)!');
      } catch (err) {
        console.error('‚ùå L·ªói khi ƒëƒÉng k√Ω l·∫°i webhook:', err.response?.data || err.message);
      }            
      
      res.redirect('/?auth=success');
    } catch (error) {
      console.error('Chi ti·∫øt l·ªói:', {
        message: error.message,
        response: error.response?.data,
        stack: error.stack
      });
      res.redirect('/?auth=failed&reason=' + encodeURIComponent(error.message));
    }
});

// API ƒëƒÉng b√†i
app.post('/api/post', async (req, res) => {
  try {
    if (!pageAccessToken) {
      return res.status(401).json({ error: 'Ch∆∞a x√°c th·ª±c v·ªõi Facebook' });
    }

    const { message, mediaUrl } = req.body;
    
    let postData = { message, access_token: pageAccessToken };
    
    // N·∫øu c√≥ ·∫£nh, ƒëƒÉng b√†i d·∫°ng photo
    if (mediaUrl) {
      postData.url = mediaUrl;
      const response = await axios.post(
        `https://graph.facebook.com/v19.0/${process.env.PAGE_ID}/photos`,
        postData
      );
      return res.json({ 
        success: true, 
        postId: response.data.id,
        type: 'photo'
      });
    }
    
    // ƒêƒÉng b√†i th∆∞·ªùng
    const response = await axios.post(
      `https://graph.facebook.com/v19.0/${process.env.PAGE_ID}/feed`,
      postData
    );
    
    res.json({ 
      success: true, 
      postId: response.data.id,
      type: 'status'
    });
  } catch (error) {
    console.error('Posting error:', error.response?.data || error.message);
    res.status(500).json({ 
      error: 'ƒêƒÉng b√†i th·∫•t b·∫°i',
      details: error.response?.data?.error || error.message
    });
  }
});

// X·ª≠ l√Ω upload c·∫£ ·∫£nh v√† video
app.post('/api/upload', upload.single('media'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Vui l√≤ng ch·ªçn file ph∆∞∆°ng ti·ªán' });
    }

    if (!pageAccessToken) {
      return res.status(401).json({ error: 'Ch∆∞a x√°c th·ª±c v·ªõi Facebook' });
    }

    const { message } = req.body;

    const isVideo = req.file.mimetype.startsWith('video/');
    const apiEndpoint = isVideo 
      ? `https://graph.facebook.com/v19.0/${process.env.PAGE_ID}/videos`
      : `https://graph.facebook.com/v19.0/${process.env.PAGE_ID}/photos`;

    const formData = new FormData();
    formData.append('access_token', pageAccessToken);
    formData.append('message', message || '');

    if (isVideo) {
      // Th√™m th√¥ng tin ƒë·∫∑c bi·ªát cho video
      formData.append('title', 'Video ƒëƒÉng t·ª´ Auto Marketing Tool');
      formData.append('published', 'true');
    }

    formData.append('source', fs.createReadStream(req.file.path));

    const response = await axios.post(apiEndpoint, formData, {
      headers: {
        ...formData.getHeaders(),
        'Content-Type': 'multipart/form-data'
      },
      // Timeout d√†i h∆°n cho video
      timeout: isVideo ? 60000 : 10000
    });

    // X√≥a file t·∫°m
    fs.unlinkSync(req.file.path);

    res.json({
      success: true,
      postId: response.data.id,
      type: isVideo ? 'video' : 'photo',
      duration: isVideo ? response.data.duration : null
    });
  } catch (error) {
    console.error('Upload error:', error.response?.data || error.message);
    if (req.file) fs.unlinkSync(req.file.path);
    res.status(500).json({
      error: `Upload ${isVideo ? 'video' : '·∫£nh'} th·∫•t b·∫°i`,
      details: error.response?.data?.error || error.message
    });
  }
});

// Th√™m endpoint m·ªõi cho l√™n l·ªãch b√†i ƒëƒÉng
app.post('/api/schedule', upload.single('media'), async (req, res) => {
  try {
    const { message, scheduled_time, mediaUrl } = req.body;
    const file = req.file;

    if (!pageAccessToken) {
      return res.status(401).json({ error: 'Ch∆∞a x√°c th·ª±c v·ªõi Facebook' });
    }

    const scheduledDate = new Date(scheduled_time);
    if (scheduledDate < new Date()) {
      return res.status(400).json({ error: 'Th·ªùi gian h·∫πn l·ªãch ph·∫£i ·ªü t∆∞∆°ng lai' });
    }

    const postId = `post_${Date.now()}`;

    // L∆∞u th√¥ng tin b√†i ƒëƒÉng
    scheduledPosts[postId] = {
      postId, // Th√™m tr∆∞·ªùng n√†y
      message,
      mediaUrl,
      file,
      scheduled_time: scheduledDate,
      status: 'scheduled'
    };

    // L√™n l·ªãch ƒëƒÉng b√†i
    const job = scheduleJob(postId, scheduledDate, async () => {
      try {
        let response;
        if (file) {
          const isVideo = file.mimetype.startsWith('video/');
          const apiEndpoint = isVideo 
            ? `https://graph.facebook.com/v19.0/${process.env.PAGE_ID}/videos`
            : `https://graph.facebook.com/v19.0/${process.env.PAGE_ID}/photos`;

          const formData = new FormData();
          formData.append('access_token', pageAccessToken);
          formData.append('message', message);
          if (isVideo) {
            formData.append('title', 'Video ƒëƒÉng t·ª´ Auto Marketing Tool');
            formData.append('published', 'true');
          }
          formData.append('source', fs.createReadStream(file.path));

          response = await axios.post(apiEndpoint, formData, {
            headers: formData.getHeaders(),
            timeout: isVideo ? 60000 : 10000
          });
          fs.unlinkSync(file.path);
        } else if (mediaUrl) {
          const isVideo = mediaUrl.match(/\.(mp4|mov|avi)$/i);
          const endpoint = isVideo 
            ? `${process.env.PAGE_ID}/videos`
            : `${process.env.PAGE_ID}/photos`;
          
          const postData = {
            message,
            access_token: pageAccessToken,
            [isVideo ? 'file_url' : 'url']: mediaUrl
          };

          response = await axios.post(`https://graph.facebook.com/v19.0/${endpoint}`, postData);
        } else {
          response = await axios.post(`https://graph.facebook.com/v19.0/${process.env.PAGE_ID}/feed`, {
            message,
            access_token: pageAccessToken
          });
        }

        scheduledPosts[postId].status = 'posted';
        scheduledPosts[postId].post_id = response.data.id;
        scheduledPosts[postId].posted_at = new Date();
      } catch (error) {
        scheduledPosts[postId].status = 'failed';
        scheduledPosts[postId].error = error.message;
        if (file) fs.unlinkSync(file.path);
      }
    });

    res.json({
      success: true,
      postId,
      scheduled_time: scheduledDate,
      status: 'scheduled'
    });
  } catch (error) {
    if (req.file) fs.unlinkSync(req.file.path);
    res.status(500).json({
      error: 'L·ªói khi l√™n l·ªãch b√†i ƒëƒÉng',
      details: error.message
    });
  }
});

// C·∫≠p nh·∫≠t endpoint l·∫•y danh s√°ch b√†i ƒëƒÉng ƒë√£ l√™n l·ªãch
app.get('/api/scheduled', (req, res) => {
  const posts = Object.values(scheduledPosts)
    .sort((a, b) => new Date(a.scheduled_time) - new Date(b.scheduled_time));
  res.json(posts);
});

// API qu·∫£n l√Ω comment m·∫´u
app.post('/api/comment-templates', async (req, res) => {
  try {
    const { content } = req.body;
    const template = await CommentTemplate.create({ 
      content,
      userId: 'user1' // Thay b·∫±ng user th·ª±c t·∫ø sau
    });
    res.json(template);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/comment-templates', async (req, res) => {
  try {
    const templates = await CommentTemplate.findAll();
    res.json(templates);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// API t·ª± ƒë·ªông comment
app.post('/api/auto-comment', async (req, res) => {
  try {
    const { postId } = req.body;
    
    if (!pageAccessToken) {
      return res.status(401).json({ error: 'Ch∆∞a x√°c th·ª±c v·ªõi Facebook' });
    }

    // L·∫•y ng·∫´u nhi√™n 1 comment m·∫´u
    const templates = await CommentTemplate.findAll();
    if (templates.length === 0) {
      return res.status(400).json({ error: 'Ch∆∞a c√≥ comment m·∫´u n√†o' });
    }

    const randomTemplate = templates[Math.floor(Math.random() * templates.length)];
    
    // G·ª≠i comment l√™n Facebook
    const response = await axios.post(
      `https://graph.facebook.com/v19.0/${postId}/comments`,
      {
        message: randomTemplate.content,
        access_token: pageAccessToken
      }
    );

    res.json({
      success: true,
      commentId: response.data.id,
      templateUsed: randomTemplate.id
    });
  } catch (error) {
    res.status(500).json({ 
      error: 'T·ª± ƒë·ªông comment th·∫•t b·∫°i',
      details: error.response?.data?.error || error.message
    });
  }
});

// API x√≥a comment m·∫´u
app.delete('/api/comment-templates/:id', async (req, res) => {
  try {
    await CommentTemplate.destroy({ where: { id: req.params.id } });
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// API l·∫•y comment m·∫´u theo ID
app.get('/api/comment-templates/:id', async (req, res) => {
  try {
    const template = await CommentTemplate.findByPk(req.params.id);
    if (!template) {
      return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y comment m·∫´u' });
    }
    res.json(template);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/page-posts', async (req, res) => {
  try {
    if (!pageAccessToken) {
      return res.status(401).json({ error: 'Ch∆∞a x√°c th·ª±c' });
    }

    const result = await axios.get(
      `https://graph.facebook.com/v19.0/${process.env.PAGE_ID}/posts?access_token=${pageAccessToken}&limit=10`
    );
    res.json(result.data.data);
  } catch (error) {
    console.error('‚ùå L·ªói khi l·∫•y b√†i ƒëƒÉng:', error.response?.data || error.message);
    res.status(500).json({
      error: 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch b√†i ƒëƒÉng',
      details: error.response?.data?.error || error.message
    });
  }
});

// OAuth Flow Login FB c√° nh√¢n
// 1. Route ƒëi·ªÅu h∆∞·ªõng ƒë·∫øn FB ƒë·ªÉ login
app.get('/auth/user', (req, res) => {
  const redirectUri = `${process.env.BASE_URL}/auth/user/callback`;
  const authUrl = `https://www.facebook.com/v19.0/dialog/oauth?client_id=${process.env.APP_ID}&redirect_uri=${redirectUri}&scope=public_profile,pages_read_engagement`;
  res.redirect(authUrl);
});

// 2. X·ª≠ l√Ω Callback
app.get('/auth/user/callback', async (req, res) => {
  const code = req.query.code;

  if (!code) return res.redirect('/?auth=failed&reason=No code received');

  try {
    // L·∫•y access token ng·∫Øn h·∫°n
    const tokenResponse = await axios.get(
      `https://graph.facebook.com/v19.0/oauth/access_token?client_id=${process.env.APP_ID}&client_secret=${process.env.APP_SECRET}&redirect_uri=${process.env.BASE_URL}/auth/user/callback&code=${code}`
    );

    const accessToken = tokenResponse.data.access_token;

    // L·∫•y th√¥ng tin user
    const userResponse = await axios.get(
      `https://graph.facebook.com/me?fields=id,name,picture&access_token=${accessToken}`
    );

    const { id, name, picture } = userResponse.data;

    // L∆∞u v√†o DB
    await UserAccount.upsert({
      facebookUserId: id,
      name,
      avatar: picture.data.url,
      accessToken,
      expiresAt: new Date(Date.now() + 60 * 60 * 1000) // 1h (t·∫°m t√≠nh)
    });

    res.redirect('/?auth_user=success');
  } catch (err) {
    console.error('‚ùå L·ªói x√°c th·ª±c ng∆∞·ªùi d√πng:', err.response?.data || err.message);
    res.redirect('/?auth_user=failed');
  }
});

// API danh s√°ch t√†i kho·∫£n ng∆∞·ªùi d√πng ƒë√£ l∆∞u
app.get('/api/user-accounts', async (req, res) => {
  try {
    const users = await UserAccount.findAll();
    res.json(users);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Auto like
app.post('/api/auto-like', async (req, res) => {
  try {
    const { postId } = req.body;

    if (!pageAccessToken) {
      return res.status(401).json({ error: 'Ch∆∞a x√°c th·ª±c v·ªõi Facebook' });
    }

    const response = await axios.post(
      `https://graph.facebook.com/v19.0/${postId}/likes`,
      null,
      {
        params: {
          access_token: pageAccessToken
        }
      }
    );

    res.json({ success: true });
  } catch (error) {
    console.error('‚ùå L·ªói auto like:', error.response?.data || error.message);
    res.status(500).json({
      error: 'Auto like th·∫•t b·∫°i',
      details: error.response?.data?.error || error.message
    });
  }
});

// Auto share
app.post('/api/auto-share', async (req, res) => {
  try {
    const { postId } = req.body;

    if (!pageAccessToken) {
      return res.status(401).json({ error: 'Ch∆∞a x√°c th·ª±c v·ªõi Facebook' });
    }

    const postUrl = `https://www.facebook.com/${process.env.PAGE_ID}/posts/${postId}`;

    const response = await axios.post(
      `https://graph.facebook.com/v19.0/${process.env.PAGE_ID}/feed`,
      {
        link: postUrl,
        access_token: pageAccessToken
      }
    );

    res.json({ success: true, sharedPostId: response.data.id });
  } catch (error) {
    console.error('‚ùå L·ªói auto share:', error.response?.data || error.message);
    res.status(500).json({
      error: 'Auto share th·∫•t b·∫°i',
      details: error.response?.data?.error || error.message
    });
  }
});

// Webhook x√°c minh (GET)
app.get('/webhook', (req, res) => {
  const VERIFY_TOKEN = process.env.FB_VERIFY_TOKEN;

  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  if (mode && token) {
    if (mode === 'subscribe' && token === VERIFY_TOKEN) {
      console.log('‚úÖ Webhook verified');
      res.status(200).send(challenge);
    } else {
      res.sendStatus(403);
    }
  }
});

app.post('/webhook', (req, res) => {
  console.log('üì• D·ªÆ LI·ªÜU TH√î NH·∫¨N ƒê∆Ø·ª¢C:', JSON.stringify(req.body, null, 2));
  const body = req.body;

  if (body.object === 'page') {
    body.entry.forEach(async function(entry) {
      const event = entry.changes?.[0];
      if (!event) return;

      console.log('üì© Nh·∫≠n s·ª± ki·ªán Webhook:', JSON.stringify(event, null, 2));

      if (
        event.field === 'feed' && 
        event.value.item === 'comment' &&
        event.value.from.id !== process.env.PAGE_ID
      ) {
        const commentId = event.value.comment_id;
        const message = event.value.message;
        const from = event.value.from;

        console.log(`üí¨ New comment from ${from.name}: "${message}" (commentId: ${commentId})`);

        // Ch·ªâ tr·∫£ l·ªùi n·∫øu AI b·∫≠t
        if (!aiReplyEnabled) {
          console.log("ü§ñ AI chatbot ƒëang T·∫ÆT ‚Äì Kh√¥ng t·ª± ƒë·ªông tr·∫£ l·ªùi comment n√†y.");
          return;
        }

        // X·ª≠ l√Ω tr·∫£ l·ªùi comment
        try {
          // G·ª≠i c√¢u h·ªèi ƒë·∫øn OpenRouter (DeepSeek V3 0324)
          const aiRes = await axios.post(
            process.env.DEEPSEEK_API_URL,
            {
              model: process.env.DEEPSEEK_MODEL,
              messages: [
                { role: "system", content: "B·∫°n l√† tr·ª£ l√Ω th√¢n thi·ªán cho m·ªôt fanpage b√°n h√†ng. H√£y tr·∫£ l·ªùi ng·∫Øn g·ªçn v√† chuy√™n nghi·ªáp." },
                { role: "user", content: message }
              ],
              temperature: 0.7,
              max_tokens: 200
            },
            {
              headers: {
                Authorization: `Bearer ${process.env.DEEPSEEK_API_KEY}`,
                "Content-Type": "application/json",
                "HTTP-Referer": "https://facebook.com/",
                "X-Title": "FB Page Bot"
              }
            }
          );

          const aiReply = aiRes.data.choices[0].message.content;
          console.log(`ü§ñ AI reply: ${aiReply}`);

          // G·ª≠i tr·∫£ l·ªùi b√¨nh lu·∫≠n l√™n Facebook
          await axios.post(
            `https://graph.facebook.com/v19.0/${commentId}/comments`,
            {
              message: aiReply,
              access_token: pageAccessToken
            }
          );

          console.log(`‚úÖ Replied to comment ${commentId}`);
        } catch (err) {
          console.error("‚ùå L·ªói khi x·ª≠ l√Ω AI comment:", err.response?.data || err.message);
        }
      }
    });

    res.status(200).send('EVENT_RECEIVED');
  } else {
    res.sendStatus(404);
  }
});

// API l·∫•y tr·∫°ng th√°i b·∫≠t/t·∫Øt AI
app.get('/api/ai-reply-enabled', (req, res) => {
  res.json({ enabled: aiReplyEnabled });
});

// API c·∫≠p nh·∫≠t tr·∫°ng th√°i b·∫≠t/t·∫Øt AI
app.post('/api/ai-reply-enabled', express.json(), (req, res) => {
  const { enabled } = req.body;
  aiReplyEnabled = !!enabled;
  res.json({ enabled: aiReplyEnabled });
});

// Kh·ªüi ƒë·ªông server
app.listen(PORT, () => {
  console.log(`Server ƒëang ch·∫°y t·∫°i http://localhost:${PORT}`);
});